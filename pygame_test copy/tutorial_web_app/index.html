<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chameleon Platformer - The Master Class</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="sidebar">
        <h3>Contents</h3>
        <ul>
            <li><a href="#intro">Introduction</a></li>
            <li><a href="#p1">1. The Engine (Game Class)</a></li>
            <li><a href="#p2">2. The Loop (Time)</a></li>
            <li><a href="#p3">3. The Player (Sprites)</a></li>
            <li><a href="#p4">4. The World (Map Parsing)</a></li>
        </ul>
    </nav>

    <main class="main-content">
        <header id="intro">
            <h1>Chameleon Platformer: Master Class</h1>
            <p>From empty file to complex platformer. Learn the <strong>Why</strong> behind every line of code.</p>
        </header>

        <!-- Phase 1 -->
        <div class="step" id="p1">
            <h2>Phase 1: The Engine (OOP Foundation)</h2>
            
            <div class="theory-box">
                <h4>Theory Corner: Why a Class?</h4>
                <p>Beginners often write code in the global scope (top of the file). This works for small scripts, but becomes a nightmare for games. By wrapping our game in a <code>Game</code> class, we gain:</p>
                <ul>
                    <li><strong>Encapsulation</strong>: All game data (score, player, level) stays safely inside the object, avoiding global variable chaos.</li>
                    <li><strong>Control</strong>: We can easy restart the game by just creating a new <code>Game()</code> instance.</li>
                    <li><strong>Standards</strong>: This is how professional engines (Unity, Godot, Unreal) structure their logic.</li>
                </ul>
            </div>

            <div class="task-box">
                <h3>Task</h3>
                <p>Create <code>app.py</code>. Implement:</p>
                <ol>
                    <li>A function <code>create_main_surface()</code> that returns a 1280x720 display.</li>
                    <li>A <code>Game</code> class. In its <code>__init__</code>, initialize `pygame` and `self.clock`.</li>
                    <li>A <code>run()</code> method that loops forever, handling the `QUIT` event.</li>
                </ol>
            </div>

            <button class="btn-toggle" data-target="code-1">Show Solution</button>
            <div id="code-1" class="code-solution">
<pre><code><span class="keyword">import</span> pygame, sys

<span class="keyword">def</span> <span class="function">create_main_surface</span>():
    <span class="keyword">return</span> pygame.display.set_mode((1280, 720))

<span class="keyword">class</span> <span class="function">Game</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        pygame.init()
        self.surface = create_main_surface()
        self.clock = pygame.time.Clock()
        pygame.display.set_caption(<span class="string">"Chameleon Platformer"</span>)

    <span class="keyword">def</span> <span class="function">run</span>(self):
        <span class="keyword">while</span> <span class="keyword">True</span>:
            <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():
                <span class="keyword">if</span> event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
            
            self.surface.fill((30, 30, 30))
            pygame.display.update()
            self.clock.tick(60)

<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:
    game = Game()
    game.run()</code></pre>
            </div>
            
            <div class="explanation">
                <h4>Code Breakdown</h4>
                <ul>
                    <li><code>pygame.init()</code>: Starts up all Pygame modules (sound, font, graphics). Without this, nothing works.</li>
                    <li><code>self.clock</code>: A tool to track time. Essential for limiting FPS so the game doesn't run at 3000 FPS on a fast PC.</li>
                    <li><code>while True</code>: The infinite "Game Loop". It never stops until we tell it to.</li>
                    <li><code>pygame.event.get()</code>: Fetches everything the user did (mouse clicks, key presses) since the last frame.</li>
                    <li><code>sys.exit()</code>: <code>pygame.quit()</code> closes the window, but <code>sys.exit()</code> actually kills the Python process.</li>
                </ul>
            </div>
        </div>

        <!-- Phase 2 -->
        <div class="step" id="p2">
            <h2>Phase 2: The Loop (Delta Time)</h2>
            
            <div class="theory-box">
                <h4>Theory Corner: What is Delta Time?</h4>
                <p>Computers process frames at different speeds. If you say "move 5 pixels per frame", a fast computer might run 120 frames/sec (moving 600px), while a slow one runs 30 frames/sec (moving 150px).</p>
                <p><strong>The Solution:</strong> Move based on <em>Time</em>, not Frames.
                <br><code>dt</code> (Delta Time) is the time in seconds since the last frame (e.g., 0.016s).
                <br>Formula: <code>New Pos = Old Pos + (Speed * dt)</code>
                <br>Now, 30FPS or 144FPS, the player moves the exact same distance in real time.</p>
            </div>

            <div class="task-box">
                <h3>Task</h3>
                <p>Refactor <code>Game</code> in <code>app.py</code> to split responsibilities.</p>
                <ol>
                    <li><code>process_input()</code>: Keep the loop clean. Handles events only.</li>
                    <li><code>update(dt)</code>: Calculate math and physics. Needs <code>dt</code> to be frame-rate independent.</li>
                    <li><code>render(surface)</code>: Only draws pixels. Never do math here.</li>
                </ol>
            </div>

            <button class="btn-toggle" data-target="code-2">Show Solution</button>
            <div id="code-2" class="code-solution">
<pre><code><span class="keyword">class</span> <span class="function">Game</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        pygame.init()
        self.surface = create_main_surface()
        self.clock = pygame.time.Clock()
        pygame.display.set_caption(<span class="string">"Chameleon Platformer"</span>)

    <span class="keyword">def</span> <span class="function">process_input</span>(self):
        <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():
            <span class="keyword">if</span> event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

    <span class="keyword">def</span> <span class="function">update</span>(self, dt):
        <span class="keyword">pass</span> <span class="comment"># Logic goes here later</span>

    <span class="keyword">def</span> <span class="function">render</span>(self, surface):
        surface.fill((30, 30, 30))
        pygame.display.update()

    <span class="keyword">def</span> <span class="function">run</span>(self):
        <span class="keyword">while</span> <span class="keyword">True</span>:
            <span class="comment"># clock.tick(60) returns milliseconds (e.g. 16ms)</span>
            <span class="comment"># Divide by 1000 to get seconds (0.016s) for standard physics math</span>
            dt = self.clock.tick(60) / 1000.0 
            
            self.process_input()
            self.update(dt)
            self.render(self.surface)</code></pre>
            </div>
            
             <div class="explanation">
                <h4>Code Breakdown</h4>
                <ul>
                    <li><code>clock.tick(60)</code>: Pauses the program just enough to ensure we don't go OVER 60 Frames Per Second.</li>
                    <li><code>/ 1000.0</code>: Pygame gives time in milliseconds. We divide by 1000 because thinking in "Pixels per Second" (e.g. 300) is easier than "Pixels per Millisecond" (e.g. 0.3).</li>
                    <li><code>process_input() -> update() -> render()</code>: The Holy Trinity of Game Loops. Separation of Concerns makes bugs easier to find. Input bug? Check `process_input`. Drawing bug? Check `render`.</li>
                </ul>
            </div>
        </div>

        <!-- Phase 3 -->
        <div class="step" id="p3">
            <h2>Phase 3: The Player (Sprite & Vectors)</h2>
            
            <div class="theory-box">
                <h4>Theory Corner: Vectors</h4>
                <p>In math, a <strong>Vector</strong> represents direction and magnitude.</p>
                <p>Instead of tracking <code>x</code> and <code>y</code> variables separately, <code>pygame.math.Vector2(x, y)</code> lets us do this:</p>
                <p><code>position += direction * speed * dt</code></p>
                <p>This one line handles moving Left, Right, Up, Down, or Diagonally automatically!</p>
            </div>

            <div class="task-box">
                <h3>Task: NEW FILE</h3>
                <p><strong>Create a new file called <code>player.py</code></strong>.</p>
                <p>Create a `Player` class inheriting from `pygame.sprite.Sprite`.</p>
                <ol>
                    <li>In `__init__`, call <code>super().__init__()</code>. This is required to let Pygame set up the internal sprite logic.</li>
                    <li>Create `self.image` (Surface) and `self.rect` (coordinates).</li>
                    <li>Use a Vector2 for `self.direction`.</li>
                </ol>
            </div>

            <button class="btn-toggle" data-target="code-3">Show Solution</button>
            <div id="code-3" class="code-solution">
<pre><code><span class="comment"># File: player.py</span>
<span class="keyword">import</span> pygame

<span class="keyword">class</span> <span class="function">Player</span>(pygame.sprite.Sprite):
    <span class="keyword">def</span> <span class="function">__init__</span>(self, pos):
        <span class="keyword">super</span>().__init__() <span class="comment"># CRITICAL: Initialize parent class</span>
        self.image = pygame.Surface((32, 32))
        self.image.fill((255, 0, 0))
        
        <span class="comment"># Topleft puts the top-left corner at 'pos'. </span>
        <span class="comment"># You can also use center=pos</span>
        self.rect = self.image.get_rect(topleft=pos)
        
        self.direction = pygame.math.Vector2()
        self.speed = 400

    <span class="keyword">def</span> <span class="function">input</span>(self):
        keys = pygame.key.get_pressed()
        <span class="keyword">if</span> keys[pygame.K_RIGHT]: self.direction.x = 1
        <span class="keyword">elif</span> keys[pygame.K_LEFT]: self.direction.x = -1
        <span class="keyword">else</span>: self.direction.x = 0

    <span class="keyword">def</span> <span class="function">update</span>(self, dt):
        self.input()
        <span class="comment"># Move the rectangle by Speed * Time * Direction</span>
        self.rect.center += self.direction * self.speed * dt
</code></pre>
            </div>
            
            <div class="explanation">
                <h4>Code Breakdown</h4>
                <ul>
                    <li><code>super().__init__()</code>: The `Sprite` class has its own setup code. We MUST call this, or `Group.draw()` will fail mysteriously.</li>
                    <li><code>get_rect(topleft=pos)</code>: Pygame looks at the image size and creates a rectangle of that size starting at `pos`.</li>
                    <li><code>keys[pygame.K_RIGHT]</code>: Returns True if the key is held down right now. Better for movement than `KEYDOWN` events.</li>
                </ul>
            </div>
            
            <div class="task-box">
                <h3>Update app.py</h3>
                <p>Now update <code>app.py</code> to use the player.</p>
            </div>
             <button class="btn-toggle" data-target="code-3b">Show app.py Changes</button>
             <div id="code-3b" class="code-solution">
<pre><code><span class="keyword">import</span> pygame, sys
<span class="keyword">from</span> player <span class="keyword">import</span> Player

<span class="keyword">class</span> <span class="function">Game</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="comment"># ... setup code ...</span>
        
        <span class="comment"># GroupSingle is optimized for holding exactly one sprite</span>
        self.player_group = pygame.sprite.GroupSingle()
        self.player_group.add(Player((200, 200)))

    <span class="keyword">def</span> <span class="function">update</span>(self, dt):
        <span class="comment"># Automatically calls .update(dt) on every sprite in the group</span>
        self.player_group.update(dt)

    <span class="keyword">def</span> <span class="function">render</span>(self, surface):
        surface.fill((30, 30, 30))
        <span class="comment"># Automatically draws every sprite.image at sprite.rect</span>
        self.player_group.draw(surface)
        pygame.display.update()
</code></pre>
             </div>
        </div>

        <!-- Phase 4 -->
        <div class="step" id="p4">
            <h2>Phase 4: The World (Map Parsing)</h2>
            <div class="theory-box">
                <h4>Theory Corner: Iterating Grids</h4>
                <p>We use <code>enumerate(list)</code> to get both the <strong>Index</strong> (0, 1, 2) and the <strong>Item</strong> ('X', ' ').</p>
                <p>If we are at <code>col_index=5</code> and tiles are <code>64px</code> wide, the pixel position is <code>5 * 64 = 320px</code>.</p>
            </div>

            <div class="task-box">
                <h3>Task: NEW FILE</h3>
                <p><strong>Create `level.py`</strong>. Create a <code>Tile</code> sprite and a <code>Level</code> class that reads a string map.</p>
            </div>
            
            <button class="btn-toggle" data-target="code-4">Show Solution</button>
            <div id="code-4" class="code-solution">
<pre><code><span class="comment"># File: level.py</span>
<span class="keyword">import</span> pygame
<span class="keyword">from</span> player <span class="keyword">import</span> Player

<span class="keyword">class</span> <span class="function">Tile</span>(pygame.sprite.Sprite):
    <span class="keyword">def</span> <span class="function">__init__</span>(self, pos, groups):
        <span class="keyword">super</span>().__init__(groups)
        self.image = pygame.Surface((64, 64))
        self.image.fill((200, 200, 200))
        self.rect = self.image.get_rect(topleft=pos)

<span class="keyword">class</span> <span class="function">Level</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.visible_sprites = pygame.sprite.Group()
        self.setup_level()

    <span class="keyword">def</span> <span class="function">setup_level</span>(self):
        map_data = [
            <span class="string">"XXXXXXXXXXXXXXXXXXXX"</span>,
            <span class="string">"X                  X"</span>,
            <span class="string">"X        P         X"</span>,
            <span class="string">"X      XXXXX       X"</span>,
            <span class="string">"XXXXXXXXXXXXXXXXXXXX"</span>
        ]
        <span class="keyword">for</span> row_index, row <span class="keyword">in</span> enumerate(map_data):
            <span class="keyword">for</span> col_index, cell <span class="keyword">in</span> enumerate(row):
                x = col_index * 64
                y = row_index * 64
                <span class="keyword">if</span> cell == <span class="string">'X'</span>:
                    Tile((x,y), [self.visible_sprites])
                <span class="keyword">if</span> cell == <span class="string">'P'</span>:
                    self.player = Player((x,y))
                    self.visible_sprites.add(self.player)

    <span class="keyword">def</span> <span class="function">update</span>(self, dt):
        self.visible_sprites.update(dt)

    <span class="keyword">def</span> <span class="function">render</span>(self, surface):
        surface.fill((30, 30, 30))
        self.visible_sprites.draw(surface)
</code></pre>
            </div>
            
             <div class="explanation">
                <h4>Code Breakdown</h4>
                <ul>
                    <li><code>groups</code> argument in Tile: When we create a Tile, we pass the groups it belongs to. <code>super().__init__(groups)</code> automatically adds the sprite to those groups. Efficient!</li>
                    <li><code>enumerate</code> loops: We need the index (`row_index`) to calculate the Y position, and the index (`col_index`) for the X position.</li>
                </ul>
            </div>
        </div>

        <footer>
            <p>You have built a generic Platformer Engine! Next steps: Adding Polish, Enemies, and Sound.</p>
        </footer>
    </main>
    <script src="script.js"></script>
</body>
</html>
